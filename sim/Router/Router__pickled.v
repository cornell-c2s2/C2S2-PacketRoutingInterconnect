//-------------------------------------------------------------------------
// Router.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL VerilogPlaceholder routerTestHarnessVRTL Definition
// Full name: routerTestHarnessVRTL__p_nbits_4__p_noutputs_2
// At /home/jjm469/c2s2/Router/PacketRoutingInterconnect/sim/Router/routerRTL.py

//***********************************************************
// Pickled source file of placeholder routerTestHarnessVRTL__p_nbits_4__p_noutputs_2
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder routerTestHarnessVRTL
//-----------------------------------------------------------

`ifndef ROUTERTESTHARNESSVRTL
`define ROUTERTESTHARNESSVRTL

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component routerTestHarnessVRTL__p_nbits_4__p_noutputs_2.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component routerTestHarnessVRTL__p_nbits_4__p_noutputs_2

`line 1 "routerTestHarnessVRTL.v" 0
`line 1 "routerVRTL.v" 0
`line 1 "muxes.v" 0
//========================================================================
// Verilog Components: Muxes
//========================================================================

`ifndef VC_MUXES_V
`define VC_MUXES_V

//------------------------------------------------------------------------
// 2 Input Mux
//------------------------------------------------------------------------

module vc_Mux2
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1,
  input  logic               sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      1'd0 : out = in0;
      1'd1 : out = in1;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 3 Input Mux
//------------------------------------------------------------------------

module vc_Mux3
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 4 Input Mux
//------------------------------------------------------------------------

module vc_Mux4
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      2'd3 : out = in3;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 5 Input Mux
//------------------------------------------------------------------------

module vc_Mux5
#(
 parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 6 Input Mux
//------------------------------------------------------------------------

module vc_Mux6
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 7 Input Mux
//------------------------------------------------------------------------

module vc_Mux7
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 8 Input Mux
//------------------------------------------------------------------------

module vc_Mux8
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6, in7,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      3'd7 : out = in7;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// N Input Mux
//------------------------------------------------------------------------

module vc_MuxN
#(
  parameter p_nbits = 1,
  parameter p_ninputs = 2
)(
  input  logic [p_ninputs-1:0][p_nbits-1:0] in,
  input  logic [$clog2(p_ninputs)-1:0]      sel,
  output logic [p_nbits-1:0]                out
);

  assign out = in[sel];

endmodule

`endif /* VC_MUXES_V */

`line 2 "routerVRTL.v" 0
`line 1 "parametricDemuxVRTL.v" 0
module parametricDemuxVRTL
#(
  //length of message
  parameter p_nbits = 1,   
  //Number of outputs
  parameter p_noutputs = 2
)
(
  input  logic [p_nbits-1:0]                  in_val,
  input  logic [$clog2(p_noutputs)-1:0]       sel,
  output logic [p_nbits-1:0] out_val [p_noutputs-1:0]
);
  genvar i;
  generate
    for (i = 0; i < p_noutputs; i = i + 1) begin : output_gen
      assign out_val[i] = (i == sel) ? in_val : {p_nbits{1'b0}};
    end
  endgenerate
endmodule


`line 3 "routerVRTL.v" 0

module routerVRTL
#(
  parameter p_nbits = 8,
  parameter p_noutputs = 8
)(
  input logic                                                    valid,
  // input logic  [p_noutputs-1:0]                                  ready, (the orientation below is more accurate)
  input logic [p_noutputs-1:0]                                   ready, 
  input logic  [p_nbits-1:0]                                     message_in, 
  output logic                                                  ready_out,
  output logic [p_noutputs-1:0]                                 valid_out, 
  output logic [p_nbits-$clog2(p_noutputs)-1:0] message_out [p_noutputs-1:0]
);

//WHAT COMES OUT OF DEMUX (temporary val)
logic valid_holder [p_noutputs-1:0];
logic [p_nbits-1 : p_nbits-$clog2(p_noutputs)] select;
logic [p_nbits-$clog2(p_noutputs)-1:0] cut_message;

assign select = message_in[p_nbits-1 : p_nbits-$clog2(p_noutputs)];
assign cut_message = message_in[p_nbits-$clog2(p_noutputs)-1:0];

  vc_MuxN #(                   
    .p_nbits(1),               
    .p_ninputs(p_noutputs)     
  ) mux_inst (
    .in(ready),
    .sel(select),
    .out(ready_out)
  );

  parametricDemuxVRTL #(       
    .p_nbits(1),               
    .p_noutputs(p_noutputs)     
  ) demux_inst (
    .in_val(valid),
    .sel(select),
    .out_val(valid_holder)
  );

  generate
    for ( genvar j = 0; j < p_noutputs; j = j + 1) begin : output_gen
      assign valid_out[j] = (ready_out == 1) ? valid_holder[j] : 1'b0;
    end
  endgenerate

  generate
    for ( genvar k = 0; k < p_noutputs; k = k + 1) begin : output_gen
      assign message_out[k] = cut_message;
    end
  endgenerate
endmodule

`line 2 "routerTestHarnessVRTL.v" 0

 module routerTestHarnessVRTL
#(
  parameter p_nbits = 8,
  parameter p_noutputs = 8
)(
  input wire                                                    valid,
  input wire  [p_noutputs-1:0]                                  ready,
  input wire  [p_nbits-1:0]                                     message_in, 
  output logic                                                  ready_out,
  output logic [p_noutputs-1:0]                                 valid_out,
  output wire [(p_nbits-$clog2(p_noutputs))*p_noutputs-1:0]     message_out     
);


logic [(p_nbits-$clog2(p_noutputs))-1:0]  temp_message_out  [p_noutputs-1:0];
logic [p_noutputs-1:0] temp_valid_out;

  routerVRTL #(
    .p_nbits(p_nbits),
    .p_noutputs(p_noutputs)
  ) router_inst (
    .valid(valid),
    .ready(ready),
    .message_in(message_in),
    .valid_out(temp_valid_out),
    .ready_out(ready_out),
    .message_out(temp_message_out)
  );

  generate
    for (genvar i = 0; i < p_noutputs; i = i + 1) begin : output_gen
      assign valid_out[i +: 1] = temp_valid_out[p_noutputs - 1 - i];
    end
  endgenerate

  generate
    for ( genvar l = 0; l < p_noutputs; l = l + 1) begin : output_gen
      assign message_out[l*(p_nbits-$clog2(p_noutputs)) +: p_nbits-$clog2(p_noutputs)] = temp_message_out[p_noutputs-l-1];
    end
  endgenerate

  endmodule


`endif /* ROUTERTESTHARNESSVRTL */
//-----------------------------------------------------------
// Wrapper of placeholder routerTestHarnessVRTL__p_nbits_4__p_noutputs_2
//-----------------------------------------------------------

`ifndef ROUTERTESTHARNESSVRTL__P_NBITS_4__P_NOUTPUTS_2
`define ROUTERTESTHARNESSVRTL__P_NBITS_4__P_NOUTPUTS_2

module Router
(
  input logic reset,
  input logic clk,
  input logic [4-1:0] message_in ,
  output logic [6-1:0] message_out ,
  input logic [2-1:0] ready ,
  output logic [1-1:0] ready_out ,
  input logic [1-1:0] valid ,
  output logic [2-1:0] valid_out 
);
  routerTestHarnessVRTL
  #(
    .p_nbits( 4 ),
    .p_noutputs( 2 )
  ) v
  (
    .message_in( message_in ),
    .message_out( message_out ),
    .ready( ready ),
    .ready_out( ready_out ),
    .valid( valid ),
    .valid_out( valid_out )
  );
endmodule

`endif /* ROUTERTESTHARNESSVRTL__P_NBITS_4__P_NOUTPUTS_2 */

